"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const constants_1 = require("./domain/constants");
const plugin_manager_1 = require("./plugin-manager");
const inquirer_helper_1 = __importDefault(require("./domain/inquirer-helper"));
const amplify_event_1 = require("./domain/amplify-event");
async function executeCommand(context) {
    const pluginCandidates = plugin_manager_1.getPluginsWithNameAndCommand(context.pluginPlatform, context.input.plugin, context.input.command);
    if (pluginCandidates.length === 1) {
        await executePluginModuleCommand(context, pluginCandidates[0]);
    }
    else if (pluginCandidates.length > 1) {
        const answer = await inquirer_helper_1.default.prompt({
            type: 'list',
            name: 'section',
            message: 'Select the module to execute',
            choices: pluginCandidates.map(plugin => {
                const pluginOptions = {
                    name: plugin.packageName + '@' + plugin.packageVersion,
                    value: plugin,
                    short: plugin.packageName + '@' + plugin.packageVersion,
                };
                return pluginOptions;
            }),
        });
        const pluginModule = answer.section;
        await executePluginModuleCommand(context, pluginModule);
    }
}
exports.executeCommand = executeCommand;
async function executePluginModuleCommand(context, plugin) {
    const { commands, commandAliases } = plugin.manifest;
    if (!commands.includes(context.input.command)) {
        context.input.command = commandAliases[context.input.command];
    }
    if (fs_extra_1.default.existsSync(plugin.packageLocation)) {
        await raisePreEvent(context);
        const pluginModule = require(plugin.packageLocation);
        if (pluginModule.hasOwnProperty(constants_1.constants.ExecuteAmplifyCommand) &&
            typeof pluginModule[constants_1.constants.ExecuteAmplifyCommand] === 'function') {
            attachContextExtensions(context, plugin);
            await pluginModule.executeAmplifyCommand(context);
        }
        else {
            let commandFilepath = path_1.default.normalize(path_1.default.join(plugin.packageLocation, 'commands', plugin.manifest.name, context.input.command));
            if (context.input.subCommands && context.input.subCommands.length > 0) {
                commandFilepath = path_1.default.join(commandFilepath, ...context.input.subCommands);
            }
            let commandModule;
            try {
                commandModule = require(commandFilepath);
            }
            catch (e) {
            }
            if (!commandModule) {
                commandFilepath = path_1.default.normalize(path_1.default.join(plugin.packageLocation, 'commands', plugin.manifest.name));
                try {
                    commandModule = require(commandFilepath);
                }
                catch (e) {
                }
            }
            if (commandModule) {
                attachContextExtensions(context, plugin);
                await commandModule.run(context);
            }
            else {
                const { showAllHelp } = require('./extensions/amplify-helpers/show-all-help');
                showAllHelp(context);
            }
        }
        await raisePostEvent(context);
    }
    else {
        await plugin_manager_1.scan();
        context.print.error('The Amplify CLI plugin platform detected an error.');
        context.print.info('It has performed a fresh scan.');
        context.print.info('Please execute your command again.');
    }
}
async function raisePreEvent(context) {
    if (context.input.plugin === constants_1.constants.CORE) {
        if (context.input.command === 'init') {
            await raisePreInitEvent(context);
        }
        else if (context.input.command === 'push') {
            await raisePrePushEvent(context);
        }
    }
}
async function raisePreInitEvent(context) {
    await raiseEvent(context, new amplify_event_1.AmplifyEventArgs(amplify_event_1.AmplifyEvent.PreInit, new amplify_event_1.AmplifyPreInitEventData()));
}
async function raisePrePushEvent(context) {
    await raiseEvent(context, new amplify_event_1.AmplifyEventArgs(amplify_event_1.AmplifyEvent.PrePush, new amplify_event_1.AmplifyPrePushEventData()));
}
async function raisePostEvent(context) {
    if (context.input.plugin === constants_1.constants.CORE) {
        if (context.input.command === 'init') {
            await raisePostInitEvent(context);
        }
        else if (context.input.command === 'push') {
            await raisePostPushEvent(context);
        }
    }
}
async function raisePostInitEvent(context) {
    await raiseEvent(context, new amplify_event_1.AmplifyEventArgs(amplify_event_1.AmplifyEvent.PostInit, new amplify_event_1.AmplifyPostPushEventData()));
}
async function raisePostPushEvent(context) {
    await raiseEvent(context, new amplify_event_1.AmplifyEventArgs(amplify_event_1.AmplifyEvent.PostPush, new amplify_event_1.AmplifyPostInitEventData()));
}
async function raiseEvent(context, args) {
    const plugins = plugin_manager_1.getPluginsWithEventHandler(context.pluginPlatform, args.event);
    if (plugins.length > 0) {
        const sequential = require('promise-sequential');
        const eventHandlers = plugins
            .filter(plugin => {
            const exists = fs_extra_1.default.existsSync(plugin.packageLocation);
            return exists;
        })
            .map(plugin => {
            const eventHandler = async () => {
                try {
                    attachContextExtensions(context, plugin);
                    const pluginModule = require(plugin.packageLocation);
                    await pluginModule.handleAmplifyEvent(context, args);
                }
                catch {
                }
            };
            return eventHandler;
        });
        await sequential(eventHandlers);
    }
}
exports.raiseEvent = raiseEvent;
function attachContextExtensions(context, plugin) {
    const extensionsDirPath = path_1.default.normalize(path_1.default.join(plugin.packageLocation, 'extensions'));
    if (fs_extra_1.default.existsSync(extensionsDirPath)) {
        const stats = fs_extra_1.default.statSync(extensionsDirPath);
        if (stats.isDirectory()) {
            const itemNames = fs_extra_1.default.readdirSync(extensionsDirPath);
            itemNames.forEach(itemName => {
                const itemPath = path_1.default.join(extensionsDirPath, itemName);
                let itemModule;
                try {
                    itemModule = require(itemPath);
                    itemModule(context);
                }
                catch (e) {
                }
            });
        }
    }
}
//# sourceMappingURL=execution-manager.js.map